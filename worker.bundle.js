(()=>{"use strict";const t=Symbol("Comlink.proxy"),e=Symbol("Comlink.endpoint"),n=Symbol("Comlink.releaseProxy"),a=Symbol("Comlink.thrown"),s=t=>"object"==typeof t&&null!==t||"function"==typeof t,i=new Map([["proxy",{canHandle:e=>s(e)&&e[t],serialize(t){const{port1:e,port2:n}=new MessageChannel;return r(t,e),[n,[n]]},deserialize:t=>(t.start(),h(t,[],undefined))}],["throw",{canHandle:t=>s(t)&&a in t,serialize({value:t}){let e;return e=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[e,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function r(e,n=self){n.addEventListener("message",(function s(i){if(!i||!i.data)return;const{id:c,type:h,path:u}=Object.assign({path:[]},i.data),l=(i.data.argumentList||[]).map(m);let p;try{const n=u.slice(0,-1).reduce(((t,e)=>t[e]),e),a=u.reduce(((t,e)=>t[e]),e);switch(h){case"GET":p=a;break;case"SET":n[u.slice(-1)[0]]=m(i.data.value),p=!0;break;case"APPLY":p=a.apply(n,l);break;case"CONSTRUCT":p=function(e){return Object.assign(e,{[t]:!0})}(new a(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;r(e,n),p=d(t,[t])}break;case"RELEASE":p=void 0;break;default:return}}catch(t){p={value:t,[a]:0}}Promise.resolve(p).catch((t=>({value:t,[a]:0}))).then((t=>{const[e,a]=f(t);n.postMessage(Object.assign(Object.assign({},e),{id:c}),a),"RELEASE"===h&&(n.removeEventListener("message",s),o(n))}))})),n.start&&n.start()}function o(t){(function(t){return"MessagePort"===t.constructor.name})(t)&&t.close()}function c(t){if(t)throw new Error("Proxy has been released and is not useable")}function h(t,a=[],s=function(){}){let i=!1;const r=new Proxy(s,{get(e,s){if(c(i),s===n)return()=>p(t,{type:"RELEASE",path:a.map((t=>t.toString()))}).then((()=>{o(t),i=!0}));if("then"===s){if(0===a.length)return{then:()=>r};const e=p(t,{type:"GET",path:a.map((t=>t.toString()))}).then(m);return e.then.bind(e)}return h(t,[...a,s])},set(e,n,s){c(i);const[r,o]=f(s);return p(t,{type:"SET",path:[...a,n].map((t=>t.toString())),value:r},o).then(m)},apply(n,s,r){c(i);const o=a[a.length-1];if(o===e)return p(t,{type:"ENDPOINT"}).then(m);if("bind"===o)return h(t,a.slice(0,-1));const[l,d]=u(r);return p(t,{type:"APPLY",path:a.map((t=>t.toString())),argumentList:l},d).then(m)},construct(e,n){c(i);const[s,r]=u(n);return p(t,{type:"CONSTRUCT",path:a.map((t=>t.toString())),argumentList:s},r).then(m)}});return r}function u(t){const e=t.map(f);return[e.map((t=>t[0])),(n=e.map((t=>t[1])),Array.prototype.concat.apply([],n))];var n}const l=new WeakMap;function d(t,e){return l.set(t,e),t}function f(t){for(const[e,n]of i)if(n.canHandle(t)){const[a,s]=n.serialize(t);return[{type:"HANDLER",name:e,value:a},s]}return[{type:"RAW",value:t},l.get(t)||[]]}function m(t){switch(t.type){case"HANDLER":return i.get(t.name).deserialize(t.value);case"RAW":return t.value}}function p(t,e,n){return new Promise((a=>{const s=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.addEventListener("message",(function e(n){n.data&&n.data.id&&n.data.id===s&&(t.removeEventListener("message",e),a(n.data))})),t.start&&t.start(),t.postMessage(Object.assign({id:s},e),n)}))}const g=()=>{};class w{constructor(t){this.onclose=g,this.onJSONMessage=g,this.onBinaryMessage=g,this.websocket=t,this.websocket.onclose=t=>{const{code:e,reason:n,wasClean:a}=t;console.info("WebSocket closed",e,n,a),this.onclose()},this.websocket.onerror=()=>console.error("WebSocket error"),this.websocket.onmessage=t=>{const e=t.data;if(e instanceof ArrayBuffer)this.onBinaryMessage(e);else{const t=JSON.parse(e);this.onJSONMessage(t)}}}sendJSON(t){this.websocket.send(JSON.stringify(t))}sendBinary(t){this.websocket.send(t)}close(){this.websocket.readyState!==WebSocket.CLOSED&&this.websocket.close()}isOpen(){return this.websocket.readyState===WebSocket.OPEN}}function k(t,e,n){const a=new DataView(t,e,26),s=a.getUint8(5),i=(8,r=t=>0!=(s&1<<t),Array.from({length:8},((t,e)=>r(e))));var r;const o=a.getFloat32(6,!1),c=a.getFloat32(10,!1),h=a.getFloat32(14,!1);return{data:{id:a.getUint16(0,!1),headChunkId:a.getUint32(0,!1),skin:a.getUint8(4),fast:i[0],fastHistory:i,length:o,width:y(o,n),headDirection:[c,h],headPosition:{x:a.getFloat32(18,!1),y:a.getFloat32(22,!1)}},nextByteOffset:e+26}}function y(t,e){const n=e.snakes.minWidth,a=e.snakes.maxWidth-e.snakes.minWidth;var s;return n+2*(s=(t-e.snakes.minLength)/(1024-e.snakes.minLength)*3.66,1/(1+Math.exp(-s))-.5)*a}function b(t){if(!Number.isFinite(t))return 0;for(;Math.abs(t)>Math.PI;)t-=2*Math.sign(t)*Math.PI;return t}Math.PI;class x{constructor(t,e,n,a){this.minX=t,this.maxX=e,this.minY=n,this.maxY=a}static fromTransferable(t){return new x(t.minX,t.maxX,t.minY,t.maxY)}static createAt(t,e,n){const a=.5*e,s=.5*n;return new x(t.x-a,t.x+a,t.y-s,t.y+s)}static distance2(t,e){let n=0,a=0;return t.maxX<e.minX?n=e.minX-t.maxX:e.maxX<t.minX&&(n=t.minX-e.maxX),t.maxY<e.minY?a=e.minY-t.maxY:e.maxY<t.minY&&(a=t.minY-e.maxY),n*n+a*a}get width(){return this.maxX-this.minX}get height(){return this.maxY-this.minY}createTransferable(t=0){return{minX:this.minX-t,maxX:this.maxX+t,minY:this.minY-t,maxY:this.maxY+t}}extendTo(t,e=Number.EPSILON){return new x(Math.min(this.minX,t.x-e),Math.max(this.maxX,t.x+e),Math.min(this.minY,t.y-e),Math.max(this.maxY,t.y+e))}contains(t){const e=this.minX<=t.x&&t.x<this.maxX,n=this.minY<=t.y&&t.y<this.maxY;return e&&n}}class v{constructor(t,e){this.position=0,this.pathPoints=t,this.vertices=2*this.pathPoints,this.chunkPathLength=e,this.buffer=new Float32Array(6*this.vertices)}addPoint(t,e,n,a){this.checkCanAdd();const s=this.buffer;let i=this.position;this.position+=12;const r=n-.5*Math.PI,o=Math.cos(r),c=Math.sin(r),h=this.chunkPathLength-a;s[i+0]=t,s[i+1]=e,s[i+2]=o,s[i+3]=c,s[i+4]=1,s[i+5]=h,i+=6,s[i+0]=t,s[i+1]=e,s[i+2]=o,s[i+3]=c,s[i+4]=-1,s[i+5]=h}duplicateLastPoint(){this.checkCanAdd();const t=this.position,e=t-12;if(e<0)throw new Error("No point to duplicate.");this.position+=12;const n=this.buffer;for(let a=0;a<12;a++)n[t+a]=n[e+a]}checkCanAdd(){if(this.position>=this.buffer.length)throw new RangeError("Cannot add another point to vertex buffer.")}}function S(t,e,n){const a=new DataView(t,e);if(a.byteLength<21)throw new RangeError("Invalid buffer (too small for header)");const s=a.getUint16(0,!1),i=a.getUint32(0,!1),r=a.getUint8(4);let o=a.getFloat32(5,!1),c=a.getFloat32(9,!1),h=a.getFloat32(13,!1);const u=a.getFloat32(17,!1),l=21+r===96;if(!l&&0!==u)throw new Error(`Invalid chunk offset value: ${u}`);if(a.byteLength<21+r)throw new RangeError("Invalid buffer (too small)");const d=r+1,f=new Float32Array(4*d);let m,p,g,w,k=0;m=p=c,g=w=h,f[0]=c,f[1]=h,f[2]=k,f[3]=o;for(let t=0;t<r;t++){const e=a.getUint8(21+t),s=(128&e)>0,i=1+((112&e)>>4),r=M(n,15&e),u=o+.5*r;o=b(o+r);const l=i*(s?n.snakes.fastSpeed:n.snakes.speed);c+=l*Math.cos(o),h+=l*Math.sin(o),k+=l;const d=4*(t+1);f[d+0]=c,f[d+1]=h,f[d+2]=k,f[d+3]=u,m=Math.min(m,c),p=Math.max(p,c),g=Math.min(g,h),w=Math.max(w,h)}f[f.length-1]=o,k=Math.max(k,f[f.length-2]);const y=new v(d+1,k);for(let t=0;t<d;t++){const e=4*t;y.addPoint(f[e+0],f[e+1],f[e+3],f[e+2])}y.duplicateLastPoint();const S=new x(m,p,g,w);return{data:{id:i,snakeId:s,length:k,offset:u,full:l,vertices:y.vertices,data:y.buffer,boundingBox:S.createTransferable()},nextByteOffset:e+21+r}}function M(t,e){return(1-((1&e)<<1))*Math.floor(e/2)*t.snakes.maxTurnDelta/7}const E=[.64,1,1.5];function U(t,e,n){const a=new DataView(t,e),s=n.chunks.size,i=a.getUint8(0),r=a.getUint8(1),o=a.getUint16(2,!1),c=a.getUint16(0,!1),h=(i-.5*n.chunks.columns)*s,u=(r-.5*n.chunks.rows)*s,l=new Array(o);for(let t=0;t<o;t++){const e=4+3*t,n=a.getInt8(e+0)+128,i=a.getInt8(e+1)+128,r=a.getUint8(e+2),o=E[r>>6],c=63&r,d=h+n/256*s,f=u+i/256*s;l[t]={x:d,y:f,size:o,color:c}}return{data:{id:c,items:l,bounds:{minX:h,maxX:h+s,minY:u,maxY:u+s}},nextByteOffset:e+4+3*o}}function O(t,e,n,a,s){const i=new Array(n);for(let r=0;r<n;r++){const{data:n,nextByteOffset:o}=t(a,s,e);i[r]=n,s=o}return{data:i,nextByteOffset:s}}let L=null;const P=new class{constructor(t,e){this.lastRealUpdate=performance.now(),this.nextValue=null,this.timeout=void 0,this.minDelay=t,this.updateConsumer=e}setValue(t){if(void 0!==this.timeout)return void(this.nextValue=t);const e=performance.now(),n=e-this.lastRealUpdate;if(n>=this.minDelay)return this.lastRealUpdate=e,void this.updateConsumer(t);const a=this.minDelay-n;this.timeout=setTimeout((()=>{this.timeout=void 0,null!==this.nextValue&&(this.updateConsumer(this.nextValue),this.nextValue=null)}),a)}abort(){void 0!==this.timeout&&(clearTimeout(this.timeout),this.timeout=void 0)}}(1e3/30,(t=>{if(L&&L.isOpen()){const e=new ArrayBuffer(9),n=new DataView(e),a=x.fromTransferable(t.viewBox);n.setFloat32(0,a.width/a.height,!1),n.setFloat32(4,t.targetAlpha,!1),n.setUint8(8,t.wantsToBeFast?1:0),L.sendBinary(e)}})),C=new class{constructor(){this.updateQueue=[],this.snakeDeaths=[]}init(t){this.config=t.gameConfig}nextUpdate(){const t=this.updateQueue.shift(),e=this.updateQueue.length>0,n=this.leaderboard;this.leaderboard=void 0;const a=this.snakeDeaths;return this.snakeDeaths=[],{ticksSinceLastUpdate:t?t.ticksSinceLastUpdate:0,snakes:t?t.snakeInfos:[],snakeChunks:t?t.snakeChunkData:[],foodChunks:t?t.foodChunkData:[],snakeDeaths:a,leaderboard:n,heatMap:t?.heatMap,moreUpdates:e}}addBinaryUpdate(t){const e=function(t,e){const n=new DataView(e),a=n.getUint8(0),s=n.getUint8(1),i=n.getUint8(2),r=n.getUint8(3),o=0!==n.getUint8(4),{data:c,nextByteOffset:h}=O(k,t,s,e,5),{data:u,nextByteOffset:l}=O(S,t,i,e,h),{data:d,nextByteOffset:f}=O(U,t,r,e,l);let m,p=f;if(o){const n=t.chunks.rows*t.chunks.columns;p+=n;const a=new Uint8Array(e,f,n);m=new Uint8Array(a)}return p!==e.byteLength&&console.error(`Unexpected update buffer size (expected ${p}, was ${e.byteLength})`),{ticksSinceLastUpdate:a,snakeInfos:c,snakeChunkData:u,foodChunkData:d,heatMap:m}}(this.config,t);this.updateQueue.push(e)}addJSONUpdate(t){switch(t.tag){case"SnakeDeathInfo":console.info(`Snake ${t.snakeId} has died.`),this.snakeDeaths.push(t.snakeId);break;case"Leaderboard":this.leaderboard={list:t.list};break;default:throw new Error(`Unexpected message from server. (tag = ${t.tag})`)}}},A=new Map;function D(t){const e=A.get(t);e&&e()}self.onerror=(t,e,n,a,s)=>{D("error")},r(new class{async init(t,e){if(null!==L)throw new Error("Worker is already initialized.");const n=`${e.server.wss?"wss":"ws"}://${e.server.host}:${e.server.port}/game`;L=await async function(t){const e=new WebSocket(t);return e.binaryType="arraybuffer",await new Promise(((t,n)=>{e.onopen=()=>{e.onopen=null,t()},e.onerror=()=>{e.onerror=null,n()}})),new w(e)}(n);const a=await new Promise(((t,e)=>{const n=setTimeout((()=>e("SpawnInfo timeout.")),2e3);L.onJSONMessage=e=>{"SpawnInfo"===e.tag?(clearTimeout(n),t(e)):console.warn("Game init: Unexpected message from server.",e)}}));return C.init(a),L.onJSONMessage=t=>{t.tag,C.addJSONUpdate(t),D("server-update")},L.onBinaryMessage=t=>{C.addBinaryUpdate(t),D("server-update")},L.onclose=()=>{D("disconnect"),self.close()},L.sendJSON({tag:"UpdatePlayerName",name:t}),{config:C.config,targetSnakeId:a.snakeId,startPosition:{x:0,y:0}}}async sendUserInput(t,e,n){P.setValue({targetAlpha:t,wantsToBeFast:e,viewBox:n})}getDataChanges(){const t=C.nextUpdate(),e=t.snakeChunks.map((t=>t.data.buffer));return t.heatMap&&e.push(t.heatMap.buffer),d(t,e)}quit(){L&&L.close(),self.close()}addEventListener(t,e){A.set(t,e)}})})();