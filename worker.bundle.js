(()=>{"use strict";const e=Symbol("Comlink.proxy"),t=Symbol("Comlink.endpoint"),n=Symbol("Comlink.releaseProxy"),a=Symbol("Comlink.thrown"),s=e=>"object"==typeof e&&null!==e||"function"==typeof e,i=new Map([["proxy",{canHandle:t=>s(t)&&t[e],serialize(e){const{port1:t,port2:n}=new MessageChannel;return r(e,t),[n,[n]]},deserialize:e=>(e.start(),c(e,[],undefined))}],["throw",{canHandle:e=>s(e)&&a in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function r(t,n=self){n.addEventListener("message",(function s(i){if(!i||!i.data)return;const{id:h,type:c,path:u}=Object.assign({path:[]},i.data),d=(i.data.argumentList||[]).map(f);let p;try{const n=u.slice(0,-1).reduce(((e,t)=>e[t]),t),a=u.reduce(((e,t)=>e[t]),t);switch(c){case"GET":p=a;break;case"SET":n[u.slice(-1)[0]]=f(i.data.value),p=!0;break;case"APPLY":p=a.apply(n,d);break;case"CONSTRUCT":p=function(t){return Object.assign(t,{[e]:!0})}(new a(...d));break;case"ENDPOINT":{const{port1:e,port2:n}=new MessageChannel;r(t,n),p=l(e,[e])}break;case"RELEASE":p=void 0;break;default:return}}catch(e){p={value:e,[a]:0}}Promise.resolve(p).catch((e=>({value:e,[a]:0}))).then((e=>{const[t,a]=m(e);n.postMessage(Object.assign(Object.assign({},t),{id:h}),a),"RELEASE"===c&&(n.removeEventListener("message",s),o(n))}))})),n.start&&n.start()}function o(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function h(e){if(e)throw new Error("Proxy has been released and is not useable")}function c(e,a=[],s=function(){}){let i=!1;const r=new Proxy(s,{get(t,s){if(h(i),s===n)return()=>p(e,{type:"RELEASE",path:a.map((e=>e.toString()))}).then((()=>{o(e),i=!0}));if("then"===s){if(0===a.length)return{then:()=>r};const t=p(e,{type:"GET",path:a.map((e=>e.toString()))}).then(f);return t.then.bind(t)}return c(e,[...a,s])},set(t,n,s){h(i);const[r,o]=m(s);return p(e,{type:"SET",path:[...a,n].map((e=>e.toString())),value:r},o).then(f)},apply(n,s,r){h(i);const o=a[a.length-1];if(o===t)return p(e,{type:"ENDPOINT"}).then(f);if("bind"===o)return c(e,a.slice(0,-1));const[d,l]=u(r);return p(e,{type:"APPLY",path:a.map((e=>e.toString())),argumentList:d},l).then(f)},construct(t,n){h(i);const[s,r]=u(n);return p(e,{type:"CONSTRUCT",path:a.map((e=>e.toString())),argumentList:s},r).then(f)}});return r}function u(e){const t=e.map(m);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const d=new WeakMap;function l(e,t){return d.set(e,t),e}function m(e){for(const[t,n]of i)if(n.canHandle(e)){const[a,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:a},s]}return[{type:"RAW",value:e},d.get(e)||[]]}function f(e){switch(e.type){case"HANDLER":return i.get(e.name).deserialize(e.value);case"RAW":return e.value}}function p(e,t,n){return new Promise((a=>{const s=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===s&&(e.removeEventListener("message",t),a(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:s},t),n)}))}const g=()=>{};class k{constructor(e){this.onclose=g,this.onJSONMessage=g,this.onBinaryMessage=g,this.websocket=e,this.websocket.onclose=e=>{const{code:t,reason:n,wasClean:a}=e;console.info("WebSocket closed",t,n,a),this.onclose()},this.websocket.onerror=()=>console.error("WebSocket error"),this.websocket.onmessage=e=>{const t=e.data;if(t instanceof ArrayBuffer)this.onBinaryMessage(t);else{const e=JSON.parse(t);this.onJSONMessage(e)}}}sendJSON(e){this.websocket.send(JSON.stringify(e))}sendBinary(e){this.websocket.send(e)}close(){this.websocket.readyState!==WebSocket.CLOSED&&this.websocket.close()}isOpen(){return this.websocket.readyState===WebSocket.OPEN}}function w(e,t,n){const a=new DataView(e,t,26),s=a.getUint8(5),i=(8,r=e=>0!=(s&1<<e),Array.from({length:8},((e,t)=>r(t))));var r;const o=a.getFloat32(6,!1),h=a.getFloat32(10,!1),c=a.getFloat32(14,!1);return{data:{id:a.getUint16(0,!1),headChunkId:a.getUint32(0,!1),skin:a.getUint8(4),fast:i[0],fastHistory:i,length:o,width:y(o,n),headDirection:[h,c],headPosition:{x:a.getFloat32(18,!1),y:a.getFloat32(22,!1)}},nextByteOffset:t+26}}function y(e,t){const n=t.snakes.minWidth,a=t.snakes.maxWidth-t.snakes.minWidth;var s;return n+2*(s=(e-t.snakes.minLength)/(1024-t.snakes.minLength)*3.66,1/(1+Math.exp(-s))-.5)*a}function b(e){if(!Number.isFinite(e))return 0;for(;Math.abs(e)>Math.PI;)e-=2*Math.sign(e)*Math.PI;return e}Math.PI;class x{constructor(e,t,n,a){this.minX=e,this.maxX=t,this.minY=n,this.maxY=a}static fromTransferable(e){return new x(e.minX,e.maxX,e.minY,e.maxY)}static createAt(e,t,n){const a=.5*t,s=.5*n;return new x(e.x-a,e.x+a,e.y-s,e.y+s)}static distance2(e,t){let n=0,a=0;return e.maxX<t.minX?n=t.minX-e.maxX:t.maxX<e.minX&&(n=e.minX-t.maxX),e.maxY<t.minY?a=t.minY-e.maxY:t.maxY<e.minY&&(a=e.minY-t.maxY),n*n+a*a}get width(){return this.maxX-this.minX}get height(){return this.maxY-this.minY}createTransferable(e=0){return{minX:this.minX-e,maxX:this.maxX+e,minY:this.minY-e,maxY:this.maxY+e}}extendTo(e,t=Number.EPSILON){return new x(Math.min(this.minX,e.x-t),Math.max(this.maxX,e.x+t),Math.min(this.minY,e.y-t),Math.max(this.maxY,e.y+t))}contains(e){const t=this.minX<=e.x&&e.x<this.maxX,n=this.minY<=e.y&&e.y<this.maxY;return t&&n}}class S{constructor(e,t){this.position=0,this.pathPoints=e,this.vertices=2*this.pathPoints,this.chunkPathLength=t,this.buffer=new Float32Array(6*this.vertices)}addPoint(e,t,n,a){this.checkCanAdd();const s=this.buffer;let i=this.position;this.position+=12;const r=n-.5*Math.PI,o=Math.cos(r),h=Math.sin(r),c=this.chunkPathLength-a;s[i+0]=e,s[i+1]=t,s[i+2]=o,s[i+3]=h,s[i+4]=1,s[i+5]=c,i+=6,s[i+0]=e,s[i+1]=t,s[i+2]=o,s[i+3]=h,s[i+4]=-1,s[i+5]=c}duplicateLastPoint(){this.checkCanAdd();const e=this.position,t=e-12;if(t<0)throw new Error("No point to duplicate.");this.position+=12;const n=this.buffer;for(let a=0;a<12;a++)n[e+a]=n[t+a]}checkCanAdd(){if(this.position>=this.buffer.length)throw new RangeError("Cannot add another point to vertex buffer.")}}function v(e,t,n){const a=new DataView(e,t);if(a.byteLength<21)throw new RangeError("Invalid buffer (too small for header)");const s=a.getUint16(0,!1),i=a.getUint32(0,!1),r=a.getUint8(4);let o=a.getFloat32(5,!1),h=a.getFloat32(9,!1),c=a.getFloat32(13,!1);const u=a.getFloat32(17,!1),d=21+r===96;if(!d&&0!==u)throw new Error(`Invalid chunk offset value: ${u}`);if(a.byteLength<21+r)throw new RangeError("Invalid buffer (too small)");const l=r+1,m=new Float32Array(4*l);let f,p,g,k,w=0;f=p=h,g=k=c,m[0]=h,m[1]=c,m[2]=w,m[3]=o;for(let e=0;e<r;e++){const t=a.getUint8(21+e),s=(128&t)>0,i=1+((112&t)>>4),r=U(n,15&t),u=o+.5*r;o=b(o+r);const d=i*(s?n.snakes.fastSpeed:n.snakes.speed);h+=d*Math.cos(o),c+=d*Math.sin(o),w+=d;const l=4*(e+1);m[l+0]=h,m[l+1]=c,m[l+2]=w,m[l+3]=u,f=Math.min(f,h),p=Math.max(p,h),g=Math.min(g,c),k=Math.max(k,c)}m[m.length-1]=o,w=Math.max(w,m[m.length-2]);const y=new S(l+1,w);for(let e=0;e<l;e++){const t=4*e;y.addPoint(m[t+0],m[t+1],m[t+3],m[t+2])}y.duplicateLastPoint();const v=new x(f,p,g,k);return{data:{id:i,snakeId:s,length:w,offset:u,full:d,vertices:y.vertices,data:y.buffer,boundingBox:v.createTransferable()},nextByteOffset:t+21+r}}function U(e,t){return(1-((1&t)<<1))*Math.floor(t/2)*e.snakes.maxTurnDelta/7}const E=[.64,1,1.5];function M(e,t,n){const a=new DataView(e,t),s=n.chunks.size,i=a.getUint8(0),r=a.getUint8(1),o=a.getUint16(2,!1),h=a.getUint16(0,!1),c=(i-.5*n.chunks.columns)*s,u=(r-.5*n.chunks.rows)*s,d=new Array(o);for(let e=0;e<o;e++){const t=4+3*e,n=a.getInt8(t+0)+128,i=a.getInt8(t+1)+128,r=a.getUint8(t+2),o=E[r>>6],h=63&r,l=c+n/256*s,m=u+i/256*s;d[e]={x:l,y:m,size:o,color:h}}return{data:{id:h,items:d,bounds:{minX:c,maxX:c+s,minY:u,maxY:u+s}},nextByteOffset:t+4+3*o}}function L(e,t,n,a,s){const i=new Array(n);for(let r=0;r<n;r++){const{data:n,nextByteOffset:o}=e(a,s,t);i[r]=n,s=o}return{data:i,nextByteOffset:s}}let C=null;const I=new class{constructor(e,t){this.lastRealUpdate=performance.now(),this.nextValue=null,this.timeout=void 0,this.minDelay=e,this.updateConsumer=t}setValue(e){if(void 0!==this.timeout)return void(this.nextValue=e);const t=performance.now(),n=t-this.lastRealUpdate;if(n>=this.minDelay)return this.lastRealUpdate=t,void this.updateConsumer(e);const a=this.minDelay-n;this.timeout=setTimeout((()=>{this.timeout=void 0,null!==this.nextValue&&(this.updateConsumer(this.nextValue),this.nextValue=null)}),a)}abort(){void 0!==this.timeout&&(clearTimeout(this.timeout),this.timeout=void 0)}}(1e3/30,(e=>{if(C&&C.isOpen()){const t=new ArrayBuffer(9),n=new DataView(t),a=x.fromTransferable(e.viewBox);n.setFloat32(0,a.width/a.height,!1),n.setFloat32(4,e.targetAlpha,!1),n.setUint8(8,e.wantsToBeFast?1:0),C.sendBinary(t)}})),N=new class{constructor(e){this.updateQueue=[],this.snakeNames=new Map,this.serverUpdateEventTrigger=e}init(e){this.config=e.gameConfig,this.snakeNames.set(e.snakeId,e.snakeName)}nextUpdate(){const e=this.updateQueue.shift(),t=this.updateQueue.length>0;return e&&e.snakes.forEach((e=>e.name=this.snakeNames.get(e.id))),{ticksSinceLastUpdate:0,snakes:[],snakeChunks:[],foodChunks:[],snakeDeaths:[],...e,moreUpdates:t}}addBinaryUpdate(e){const t=function(e,t){const n=new DataView(t),a=n.getUint8(0),s=n.getUint8(1),i=n.getUint8(2),r=n.getUint8(3),o=0!==n.getUint8(4),{data:h,nextByteOffset:c}=L(w,e,s,t,5),{data:u,nextByteOffset:d}=L(v,e,i,t,c),{data:l,nextByteOffset:m}=L(M,e,r,t,d);let f,p=m;if(o){const n=e.chunks.rows*e.chunks.columns;p+=n;const a=new Uint8Array(t,m,n);f=new Uint8Array(a)}return p!==t.byteLength&&console.error(`Unexpected update buffer size (expected ${p}, was ${t.byteLength})`),{ticksSinceLastUpdate:a,snakeInfos:h,snakeChunkData:u,foodChunkData:l,heatMap:f}}(this.config,e);t.ticksSinceLastUpdate<=0&&console.error(`Binary update not supported! ticks: ${t.ticksSinceLastUpdate}`);const n=this.updateQueue.length>0&&0===this.updateQueue[this.updateQueue.length-1].ticksSinceLastUpdate,a=n?this.updateQueue[this.updateQueue.length-1]:{ticksSinceLastUpdate:0,snakes:[],snakeChunks:[],foodChunks:[],snakeDeaths:[]};a.ticksSinceLastUpdate=t.ticksSinceLastUpdate,a.snakes.push(...t.snakeInfos),a.snakeChunks.push(...t.snakeChunkData),a.foodChunks.push(...t.foodChunkData),t.heatMap&&(a.heatMap=t.heatMap),n||this.updateQueue.push(a),this.duration>.5&&console.warn(`Update congestion! Current delay: ${this.duration.toFixed(2)}s`),this.triggerUpdateEvent()}addJSONUpdate(e){switch(e.tag){case"SnakeDeathInfo":console.info(`Snake ${e.deadSnakeId} has died.`),this.addInformation({snakeDeaths:[{deadSnakeId:e.deadSnakeId,killer:void 0!==e.killerSnakeId?{snakeId:e.killerSnakeId,name:this.getSnakeName(e.killerSnakeId)}:void 0}]}),this.snakeNames.delete(e.deadSnakeId),this.triggerUpdateEvent();break;case"GameStatistics":this.addInformation({leaderboard:(({tag:e,...t})=>t)(e)}),e.leaderboard.forEach((({id:e,name:t})=>this.snakeNames.set(e,t))),this.triggerUpdateEvent();break;case"SnakeNameUpdate":for(const[t,n]of Object.entries(e.names)){const e=parseInt(t,10);this.snakeNames.set(e,n)}break;default:throw new Error(`Unexpected message from server. (tag = ${e.tag})`)}}get duration(){return this.config.tickDuration*this.updateQueue.map((e=>e.ticksSinceLastUpdate)).reduce(((e,t)=>e+t),0)}addInformation(e){let t;0===this.updateQueue.length?(t={ticksSinceLastUpdate:0,snakes:[],snakeChunks:[],foodChunks:[],snakeDeaths:[]},this.updateQueue.push(t)):t=this.updateQueue[this.updateQueue.length-1],e.leaderboard&&(t.leaderboard=e.leaderboard),e.snakeDeaths&&t.snakeDeaths.push(...e.snakeDeaths)}triggerUpdateEvent(){this.serverUpdateEventTrigger&&this.serverUpdateEventTrigger()}getSnakeName(e){return this.snakeNames.get(e)??`Snake ${e}`}}((()=>P("server-update"))),O=new Map;function P(e){const t=O.get(e);t&&t()}self.onerror=(e,t,n,a,s)=>{P("error")},r(new class{async init(e){if(null!==C)throw new Error("Worker is already initialized.");const t=`${e.server.wss?"wss":"ws"}://${e.server.host}:${e.server.port}/game`;C=await async function(e){const t=new WebSocket(e);return t.binaryType="arraybuffer",await new Promise(((e,n)=>{t.onopen=()=>{t.onopen=null,e()},t.onerror=()=>{t.onerror=null,n()}})),new k(t)}(t);const n=await new Promise(((e,t)=>{const n=setTimeout((()=>t(new Error("SpawnInfo timeout."))),2e3);C.onJSONMessage=t=>{"SpawnInfo"===t.tag?(clearTimeout(n),e(t)):console.warn("Game init: Unexpected message from server.",t)}}));return N.init(n),C.onJSONMessage=e=>{e.tag,N.addJSONUpdate(e)},C.onBinaryMessage=e=>{N.addBinaryUpdate(e)},C.onclose=()=>{P("disconnect"),self.close()},{config:N.config,targetSnakeId:n.snakeId,startPosition:n.snakePosition}}sendUserInput(e,t,n){I.setValue({targetAlpha:e,wantsToBeFast:t,viewBox:n})}getDataChanges(){const e=N.nextUpdate(),t=e.snakeChunks.map((e=>e.data.buffer));return e.heatMap&&t.push(e.heatMap.buffer),l(e,t)}quit(){C&&C.close(),self.close()}addEventListener(e,t){O.set(e,t)}})})();