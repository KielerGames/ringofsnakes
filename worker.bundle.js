(()=>{"use strict";const t=Symbol("Comlink.proxy"),e=Symbol("Comlink.endpoint"),n=Symbol("Comlink.releaseProxy"),s=Symbol("Comlink.thrown"),a=t=>"object"==typeof t&&null!==t||"function"==typeof t,i=new Map([["proxy",{canHandle:e=>a(e)&&e[t],serialize(t){const{port1:e,port2:n}=new MessageChannel;return r(t,e),[n,[n]]},deserialize:t=>(t.start(),h(t,[],undefined))}],["throw",{canHandle:t=>a(t)&&s in t,serialize({value:t}){let e;return e=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[e,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function r(e,n=self){n.addEventListener("message",(function a(i){if(!i||!i.data)return;const{id:c,type:h,path:u}=Object.assign({path:[]},i.data),l=(i.data.argumentList||[]).map(m);let g;try{const n=u.slice(0,-1).reduce(((t,e)=>t[e]),e),s=u.reduce(((t,e)=>t[e]),e);switch(h){case"GET":g=s;break;case"SET":n[u.slice(-1)[0]]=m(i.data.value),g=!0;break;case"APPLY":g=s.apply(n,l);break;case"CONSTRUCT":g=function(e){return Object.assign(e,{[t]:!0})}(new s(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;r(e,n),g=d(t,[t])}break;case"RELEASE":g=void 0;break;default:return}}catch(t){g={value:t,[s]:0}}Promise.resolve(g).catch((t=>({value:t,[s]:0}))).then((t=>{const[e,s]=f(t);n.postMessage(Object.assign(Object.assign({},e),{id:c}),s),"RELEASE"===h&&(n.removeEventListener("message",a),o(n))}))})),n.start&&n.start()}function o(t){(function(t){return"MessagePort"===t.constructor.name})(t)&&t.close()}function c(t){if(t)throw new Error("Proxy has been released and is not useable")}function h(t,s=[],a=function(){}){let i=!1;const r=new Proxy(a,{get(e,a){if(c(i),a===n)return()=>g(t,{type:"RELEASE",path:s.map((t=>t.toString()))}).then((()=>{o(t),i=!0}));if("then"===a){if(0===s.length)return{then:()=>r};const e=g(t,{type:"GET",path:s.map((t=>t.toString()))}).then(m);return e.then.bind(e)}return h(t,[...s,a])},set(e,n,a){c(i);const[r,o]=f(a);return g(t,{type:"SET",path:[...s,n].map((t=>t.toString())),value:r},o).then(m)},apply(n,a,r){c(i);const o=s[s.length-1];if(o===e)return g(t,{type:"ENDPOINT"}).then(m);if("bind"===o)return h(t,s.slice(0,-1));const[l,d]=u(r);return g(t,{type:"APPLY",path:s.map((t=>t.toString())),argumentList:l},d).then(m)},construct(e,n){c(i);const[a,r]=u(n);return g(t,{type:"CONSTRUCT",path:s.map((t=>t.toString())),argumentList:a},r).then(m)}});return r}function u(t){const e=t.map(f);return[e.map((t=>t[0])),(n=e.map((t=>t[1])),Array.prototype.concat.apply([],n))];var n}const l=new WeakMap;function d(t,e){return l.set(t,e),t}function f(t){for(const[e,n]of i)if(n.canHandle(t)){const[s,a]=n.serialize(t);return[{type:"HANDLER",name:e,value:s},a]}return[{type:"RAW",value:t},l.get(t)||[]]}function m(t){switch(t.type){case"HANDLER":return i.get(t.name).deserialize(t.value);case"RAW":return t.value}}function g(t,e,n){return new Promise((s=>{const a=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.addEventListener("message",(function e(n){n.data&&n.data.id&&n.data.id===a&&(t.removeEventListener("message",e),s(n.data))})),t.start&&t.start(),t.postMessage(Object.assign({id:a},e),n)}))}const p=()=>{};class w{constructor(t){this.onclose=p,this.onJSONMessage=p,this.onBinaryMessage=p,this.websocket=t,this.websocket.onclose=t=>{const{code:e,reason:n,wasClean:s}=t;console.info("WebSocket closed",e,n,s),this.onclose()},this.websocket.onerror=()=>console.error("WebSocket error"),this.websocket.onmessage=t=>{const e=t.data;if(e instanceof ArrayBuffer)this.onBinaryMessage(e);else{const t=JSON.parse(e);this.onJSONMessage(t)}}}sendJSON(t){this.websocket.send(JSON.stringify(t))}sendBinary(t){this.websocket.send(t)}close(){this.websocket.readyState!==WebSocket.CLOSED&&this.websocket.close()}isOpen(){return this.websocket.readyState===WebSocket.OPEN}}function k(t,e,n){const s=new DataView(t,e,26),a=s.getUint8(5),i=(8,r=t=>0!=(a&1<<t),Array.from({length:8},((t,e)=>r(e))));var r;const o=s.getFloat32(6,!1),c=s.getFloat32(10,!1),h=s.getFloat32(14,!1);return{data:{id:s.getUint16(0,!1),headChunkId:s.getUint32(0,!1),skin:s.getUint8(4),fast:i[0],fastHistory:i,length:o,width:y(o,n),headDirection:[c,h],headPosition:{x:s.getFloat32(18,!1),y:s.getFloat32(22,!1)}},nextByteOffset:e+26}}function y(t,e){const n=e.snakes.minWidth,s=e.snakes.maxWidth-e.snakes.minWidth;var a;return n+2*(a=(t-e.snakes.minLength)/(1024-e.snakes.minLength)*3.66,1/(1+Math.exp(-a))-.5)*s}function x(t){if(!Number.isFinite(t))return 0;for(;Math.abs(t)>Math.PI;)t-=2*Math.sign(t)*Math.PI;return t}Math.PI;class b{constructor(t,e,n,s){this.minX=t,this.maxX=e,this.minY=n,this.maxY=s}static fromTransferable(t){return new b(t.minX,t.maxX,t.minY,t.maxY)}static createAt(t,e,n){const s=.5*e,a=.5*n;return new b(t.x-s,t.x+s,t.y-a,t.y+a)}static distance2(t,e){let n=0,s=0;return t.maxX<e.minX?n=e.minX-t.maxX:e.maxX<t.minX&&(n=t.minX-e.maxX),t.maxY<e.minY?s=e.minY-t.maxY:e.maxY<t.minY&&(s=t.minY-e.maxY),n*n+s*s}get width(){return this.maxX-this.minX}get height(){return this.maxY-this.minY}createTransferable(t=0){return{minX:this.minX-t,maxX:this.maxX+t,minY:this.minY-t,maxY:this.maxY+t}}extendTo(t,e=Number.EPSILON){return new b(Math.min(this.minX,t.x-e),Math.max(this.maxX,t.x+e),Math.min(this.minY,t.y-e),Math.max(this.maxY,t.y+e))}contains(t){const e=this.minX<=t.x&&t.x<this.maxX,n=this.minY<=t.y&&t.y<this.maxY;return e&&n}}class v{constructor(t,e){this.position=0,this.pathPoints=t,this.vertices=2*this.pathPoints,this.chunkPathLength=e,this.buffer=new Float32Array(6*this.vertices)}addPoint(t,e,n,s){this.checkCanAdd();const a=this.buffer;let i=this.position;this.position+=12;const r=n-.5*Math.PI,o=Math.cos(r),c=Math.sin(r),h=this.chunkPathLength-s;a[i+0]=t,a[i+1]=e,a[i+2]=o,a[i+3]=c,a[i+4]=1,a[i+5]=h,i+=6,a[i+0]=t,a[i+1]=e,a[i+2]=o,a[i+3]=c,a[i+4]=-1,a[i+5]=h}duplicateLastPoint(){this.checkCanAdd();const t=this.position,e=t-12;if(e<0)throw new Error("No point to duplicate.");this.position+=12;const n=this.buffer;for(let s=0;s<12;s++)n[t+s]=n[e+s]}checkCanAdd(){if(this.position>=this.buffer.length)throw new RangeError("Cannot add another point to vertex buffer.")}}function S(t,e,n){const s=new DataView(t,e);if(s.byteLength<21)throw new RangeError("Invalid buffer (too small for header)");const a=s.getUint16(0,!1),i=s.getUint32(0,!1),r=s.getUint8(4);let o=s.getFloat32(5,!1),c=s.getFloat32(9,!1),h=s.getFloat32(13,!1);const u=s.getFloat32(17,!1),l=21+r===96;if(!l&&0!==u)throw new Error(`Invalid chunk offset value: ${u}`);if(s.byteLength<21+r)throw new RangeError("Invalid buffer (too small)");const d=r+1,f=new Float32Array(4*d);let m,g,p,w,k=0;m=g=c,p=w=h,f[0]=c,f[1]=h,f[2]=k,f[3]=o;for(let t=0;t<r;t++){const e=s.getUint8(21+t),a=(128&e)>0,i=1+((112&e)>>4),r=E(n,15&e),u=o+.5*r;o=x(o+r);const l=i*(a?n.snakes.fastSpeed:n.snakes.speed);c+=l*Math.cos(o),h+=l*Math.sin(o),k+=l;const d=4*(t+1);f[d+0]=c,f[d+1]=h,f[d+2]=k,f[d+3]=u,m=Math.min(m,c),g=Math.max(g,c),p=Math.min(p,h),w=Math.max(w,h)}f[f.length-1]=o,k=Math.max(k,f[f.length-2]);const y=new v(d+1,k);for(let t=0;t<d;t++){const e=4*t;y.addPoint(f[e+0],f[e+1],f[e+3],f[e+2])}y.duplicateLastPoint();const S=new b(m,g,p,w);return{data:{id:i,snakeId:a,length:k,offset:u,full:l,vertices:y.vertices,data:y.buffer,boundingBox:S.createTransferable()},nextByteOffset:e+21+r}}function E(t,e){return(1-((1&e)<<1))*Math.floor(e/2)*t.snakes.maxTurnDelta/7}const M=[.64,1,1.5];function U(t,e,n){const s=new DataView(t,e),a=n.chunks.size,i=s.getUint8(0),r=s.getUint8(1),o=s.getUint16(2,!1),c=s.getUint16(0,!1),h=(i-.5*n.chunks.columns)*a,u=(r-.5*n.chunks.rows)*a,l=new Array(o);for(let t=0;t<o;t++){const e=4+3*t,n=s.getInt8(e+0)+128,i=s.getInt8(e+1)+128,r=s.getUint8(e+2),o=M[r>>6],c=63&r,d=h+n/256*a,f=u+i/256*a;l[t]={x:d,y:f,size:o,color:c}}return{data:{id:c,items:l,bounds:{minX:h,maxX:h+a,minY:u,maxY:u+a}},nextByteOffset:e+4+3*o}}function O(t,e,n,s,a){const i=new Array(n);for(let r=0;r<n;r++){const{data:n,nextByteOffset:o}=t(s,a,e);i[r]=n,a=o}return{data:i,nextByteOffset:a}}let L=null;const P=new class{constructor(t,e){this.lastRealUpdate=performance.now(),this.nextValue=null,this.timeout=void 0,this.minDelay=t,this.updateConsumer=e}setValue(t){if(void 0!==this.timeout)return void(this.nextValue=t);const e=performance.now(),n=e-this.lastRealUpdate;if(n>=this.minDelay)return this.lastRealUpdate=e,void this.updateConsumer(t);const s=this.minDelay-n;this.timeout=setTimeout((()=>{this.timeout=void 0,null!==this.nextValue&&(this.updateConsumer(this.nextValue),this.nextValue=null)}),s)}abort(){void 0!==this.timeout&&(clearTimeout(this.timeout),this.timeout=void 0)}}(1e3/30,(t=>{if(L&&L.isOpen()){const e=new ArrayBuffer(9),n=new DataView(e),s=b.fromTransferable(t.viewBox);n.setFloat32(0,s.width/s.height,!1),n.setFloat32(4,t.targetAlpha,!1),n.setUint8(8,t.wantsToBeFast?1:0),L.sendBinary(e)}})),C=new class{constructor(){this.updateQueue=[],this.snakeDeaths=[]}init(t){this.config=t.gameConfig}nextUpdate(){const t=this.updateQueue.shift(),e=this.updateQueue.length>0,n=this.leaderboard;this.leaderboard=void 0;const s=this.snakeDeaths;return this.snakeDeaths=[],{ticksSinceLastUpdate:t?t.ticksSinceLastUpdate:0,snakes:t?t.snakeInfos:[],snakeChunks:t?t.snakeChunkData:[],foodChunks:t?t.foodChunkData:[],snakeDeaths:s,leaderboard:n,moreUpdates:e}}addBinaryUpdate(t){const e=function(t,e){const n=new DataView(e),s=n.getUint8(0),a=n.getUint8(1),i=n.getUint8(2),r=n.getUint8(3),{data:o,nextByteOffset:c}=O(k,t,a,e,4),{data:h,nextByteOffset:u}=O(S,t,i,e,c),{data:l,nextByteOffset:d}=O(U,t,r,e,u);return d!==e.byteLength&&console.error(`Unexpected update buffer size (expected ${d}, was ${e.byteLength})`),{ticksSinceLastUpdate:s,snakeInfos:o,snakeChunkData:h,foodChunkData:l}}(this.config,t);this.updateQueue.push(e)}addJSONUpdate(t){switch(t.tag){case"SnakeDeathInfo":console.info(`Snake ${t.snakeId} has died.`),this.snakeDeaths.push(t.snakeId);break;case"Leaderboard":this.leaderboard={list:t.list};break;default:throw new Error(`Unexpected message from server. (tag = ${t.tag})`)}}},A=new Map;function D(t){const e=A.get(t);e&&e()}self.onerror=(t,e,n,s,a)=>{D("error")},r(new class{async init(t,e){if(null!==L)throw new Error("Worker is already initialized.");const n=`${e.server.wss?"wss":"ws"}://${e.server.host}:${e.server.port}/game`;L=await async function(t){const e=new WebSocket(t);return e.binaryType="arraybuffer",await new Promise(((t,n)=>{e.onopen=()=>{e.onopen=null,t()},e.onerror=()=>{e.onerror=null,n()}})),new w(e)}(n);const s=await new Promise(((t,e)=>{const n=setTimeout((()=>e("SpawnInfo timeout.")),2e3);L.onJSONMessage=e=>{"SpawnInfo"===e.tag?(clearTimeout(n),t(e)):console.warn("Game init: Unexpected message from server.",e)}}));return C.init(s),L.onJSONMessage=t=>{t.tag,C.addJSONUpdate(t),D("server-update")},L.onBinaryMessage=t=>{C.addBinaryUpdate(t),D("server-update")},L.onclose=()=>{D("disconnect"),self.close()},L.sendJSON({tag:"UpdatePlayerName",name:t}),{config:C.config,targetSnakeId:s.snakeId,startPosition:{x:0,y:0}}}async sendUserInput(t,e,n){P.setValue({targetAlpha:t,wantsToBeFast:e,viewBox:n})}getDataChanges(){const t=C.nextUpdate(),e=t.snakeChunks.map((t=>t.data.buffer));return d(t,e)}quit(){L&&L.close(),self.close()}addEventListener(t,e){A.set(t,e)}})})();