(()=>{"use strict";const t=Symbol("Comlink.proxy"),e=Symbol("Comlink.endpoint"),n=Symbol("Comlink.releaseProxy"),s=Symbol("Comlink.thrown"),a=t=>"object"==typeof t&&null!==t||"function"==typeof t,i=new Map([["proxy",{canHandle:e=>a(e)&&e[t],serialize(t){const{port1:e,port2:n}=new MessageChannel;return r(t,e),[n,[n]]},deserialize:t=>(t.start(),h(t,[],undefined))}],["throw",{canHandle:t=>a(t)&&s in t,serialize({value:t}){let e;return e=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[e,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function r(e,n=self){n.addEventListener("message",(function a(i){if(!i||!i.data)return;const{id:c,type:h,path:u}=Object.assign({path:[]},i.data),l=(i.data.argumentList||[]).map(f);let p;try{const n=u.slice(0,-1).reduce(((t,e)=>t[e]),e),s=u.reduce(((t,e)=>t[e]),e);switch(h){case"GET":p=s;break;case"SET":n[u.slice(-1)[0]]=f(i.data.value),p=!0;break;case"APPLY":p=s.apply(n,l);break;case"CONSTRUCT":p=function(e){return Object.assign(e,{[t]:!0})}(new s(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;r(e,n),p=d(t,[t])}break;case"RELEASE":p=void 0;break;default:return}}catch(t){p={value:t,[s]:0}}Promise.resolve(p).catch((t=>({value:t,[s]:0}))).then((t=>{const[e,s]=m(t);n.postMessage(Object.assign(Object.assign({},e),{id:c}),s),"RELEASE"===h&&(n.removeEventListener("message",a),o(n))}))})),n.start&&n.start()}function o(t){(function(t){return"MessagePort"===t.constructor.name})(t)&&t.close()}function c(t){if(t)throw new Error("Proxy has been released and is not useable")}function h(t,s=[],a=function(){}){let i=!1;const r=new Proxy(a,{get(e,a){if(c(i),a===n)return()=>p(t,{type:"RELEASE",path:s.map((t=>t.toString()))}).then((()=>{o(t),i=!0}));if("then"===a){if(0===s.length)return{then:()=>r};const e=p(t,{type:"GET",path:s.map((t=>t.toString()))}).then(f);return e.then.bind(e)}return h(t,[...s,a])},set(e,n,a){c(i);const[r,o]=m(a);return p(t,{type:"SET",path:[...s,n].map((t=>t.toString())),value:r},o).then(f)},apply(n,a,r){c(i);const o=s[s.length-1];if(o===e)return p(t,{type:"ENDPOINT"}).then(f);if("bind"===o)return h(t,s.slice(0,-1));const[l,d]=u(r);return p(t,{type:"APPLY",path:s.map((t=>t.toString())),argumentList:l},d).then(f)},construct(e,n){c(i);const[a,r]=u(n);return p(t,{type:"CONSTRUCT",path:s.map((t=>t.toString())),argumentList:a},r).then(f)}});return r}function u(t){const e=t.map(m);return[e.map((t=>t[0])),(n=e.map((t=>t[1])),Array.prototype.concat.apply([],n))];var n}const l=new WeakMap;function d(t,e){return l.set(t,e),t}function m(t){for(const[e,n]of i)if(n.canHandle(t)){const[s,a]=n.serialize(t);return[{type:"HANDLER",name:e,value:s},a]}return[{type:"RAW",value:t},l.get(t)||[]]}function f(t){switch(t.type){case"HANDLER":return i.get(t.name).deserialize(t.value);case"RAW":return t.value}}function p(t,e,n){return new Promise((s=>{const a=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.addEventListener("message",(function e(n){n.data&&n.data.id&&n.data.id===a&&(t.removeEventListener("message",e),s(n.data))})),t.start&&t.start(),t.postMessage(Object.assign({id:a},e),n)}))}const g=()=>{};class w{constructor(t){this.onclose=g,this.onJSONMessage=g,this.onBinaryMessage=g,this.websocket=t,this.websocket.onclose=t=>{const{code:e,reason:n,wasClean:s}=t;console.info("WebSocket closed",e,n,s),this.onclose()},this.websocket.onerror=()=>console.error("WebSocket error"),this.websocket.onmessage=t=>{const e=t.data;if(e instanceof ArrayBuffer)this.onBinaryMessage(e);else{const t=JSON.parse(e);this.onJSONMessage(t)}}}sendJSON(t){this.websocket.send(JSON.stringify(t))}sendBinary(t){this.websocket.send(t)}close(){this.websocket.readyState!==WebSocket.CLOSED&&this.websocket.close()}isOpen(){return this.websocket.readyState===WebSocket.OPEN}}function k(t,e,n){const s=new DataView(t,e,26),a=s.getUint8(5),i=(8,r=t=>0!=(a&1<<t),Array.from({length:8},((t,e)=>r(e))));var r;const o=s.getFloat32(6,!1),c=s.getFloat32(10,!1),h=s.getFloat32(14,!1);return{data:{id:s.getUint16(0,!1),headChunkId:s.getUint32(0,!1),skin:s.getUint8(4),fast:i[0],fastHistory:i,length:o,width:y(o,n),headDirection:[c,h],headPosition:{x:s.getFloat32(18,!1),y:s.getFloat32(22,!1)}},nextByteOffset:e+26}}function y(t,e){const n=e.snakes.minWidth,s=e.snakes.maxWidth-e.snakes.minWidth;var a;return n+2*(a=(t-e.snakes.minLength)/(1024-e.snakes.minLength)*3.66,1/(1+Math.exp(-a))-.5)*s}function b(t){if(!Number.isFinite(t))return 0;for(;Math.abs(t)>Math.PI;)t-=2*Math.sign(t)*Math.PI;return t}Math.PI;class x{constructor(t,e,n,s){this.minX=t,this.maxX=e,this.minY=n,this.maxY=s}static fromTransferable(t){return new x(t.minX,t.maxX,t.minY,t.maxY)}static createAt(t,e,n){const s=.5*e,a=.5*n;return new x(t.x-s,t.x+s,t.y-a,t.y+a)}static distance2(t,e){let n=0,s=0;return t.maxX<e.minX?n=e.minX-t.maxX:e.maxX<t.minX&&(n=t.minX-e.maxX),t.maxY<e.minY?s=e.minY-t.maxY:e.maxY<t.minY&&(s=t.minY-e.maxY),n*n+s*s}get width(){return this.maxX-this.minX}get height(){return this.maxY-this.minY}createTransferable(t=0){return{minX:this.minX-t,maxX:this.maxX+t,minY:this.minY-t,maxY:this.maxY+t}}extendTo(t,e=Number.EPSILON){return new x(Math.min(this.minX,t.x-e),Math.max(this.maxX,t.x+e),Math.min(this.minY,t.y-e),Math.max(this.maxY,t.y+e))}contains(t){const e=this.minX<=t.x&&t.x<this.maxX,n=this.minY<=t.y&&t.y<this.maxY;return e&&n}}class v{constructor(t,e){this.position=0,this.pathPoints=t,this.vertices=2*this.pathPoints,this.chunkPathLength=e,this.buffer=new Float32Array(6*this.vertices)}addPoint(t,e,n,s){this.checkCanAdd();const a=this.buffer;let i=this.position;this.position+=12;const r=n-.5*Math.PI,o=Math.cos(r),c=Math.sin(r),h=this.chunkPathLength-s;a[i+0]=t,a[i+1]=e,a[i+2]=o,a[i+3]=c,a[i+4]=1,a[i+5]=h,i+=6,a[i+0]=t,a[i+1]=e,a[i+2]=o,a[i+3]=c,a[i+4]=-1,a[i+5]=h}duplicateLastPoint(){this.checkCanAdd();const t=this.position,e=t-12;if(e<0)throw new Error("No point to duplicate.");this.position+=12;const n=this.buffer;for(let s=0;s<12;s++)n[t+s]=n[e+s]}checkCanAdd(){if(this.position>=this.buffer.length)throw new RangeError("Cannot add another point to vertex buffer.")}}function S(t,e,n){const s=new DataView(t,e);if(s.byteLength<21)throw new RangeError("Invalid buffer (too small for header)");const a=s.getUint16(0,!1),i=s.getUint32(0,!1),r=s.getUint8(4);let o=s.getFloat32(5,!1),c=s.getFloat32(9,!1),h=s.getFloat32(13,!1);const u=s.getFloat32(17,!1),l=21+r===96;if(!l&&0!==u)throw new Error(`Invalid chunk offset value: ${u}`);if(s.byteLength<21+r)throw new RangeError("Invalid buffer (too small)");const d=r+1,m=new Float32Array(4*d);let f,p,g,w,k=0;f=p=c,g=w=h,m[0]=c,m[1]=h,m[2]=k,m[3]=o;for(let t=0;t<r;t++){const e=s.getUint8(21+t),a=(128&e)>0,i=1+((112&e)>>4),r=M(n,15&e),u=o+.5*r;o=b(o+r);const l=i*(a?n.snakes.fastSpeed:n.snakes.speed);c+=l*Math.cos(o),h+=l*Math.sin(o),k+=l;const d=4*(t+1);m[d+0]=c,m[d+1]=h,m[d+2]=k,m[d+3]=u,f=Math.min(f,c),p=Math.max(p,c),g=Math.min(g,h),w=Math.max(w,h)}m[m.length-1]=o,k=Math.max(k,m[m.length-2]);const y=new v(d+1,k);for(let t=0;t<d;t++){const e=4*t;y.addPoint(m[e+0],m[e+1],m[e+3],m[e+2])}y.duplicateLastPoint();const S=new x(f,p,g,w);return{data:{id:i,snakeId:a,length:k,offset:u,full:l,vertices:y.vertices,data:y.buffer,boundingBox:S.createTransferable()},nextByteOffset:e+21+r}}function M(t,e){return(1-((1&e)<<1))*Math.floor(e/2)*t.snakes.maxTurnDelta/7}const E=[.64,1,1.5];function U(t,e,n){const s=new DataView(t,e),a=n.chunks.size,i=s.getUint8(0),r=s.getUint8(1),o=s.getUint16(2,!1),c=s.getUint16(0,!1),h=(i-.5*n.chunks.columns)*a,u=(r-.5*n.chunks.rows)*a,l=new Array(o);for(let t=0;t<o;t++){const e=4+3*t,n=s.getInt8(e+0)+128,i=s.getInt8(e+1)+128,r=s.getUint8(e+2),o=E[r>>6],c=63&r,d=h+n/256*a,m=u+i/256*a;l[t]={x:d,y:m,size:o,color:c}}return{data:{id:c,items:l,bounds:{minX:h,maxX:h+a,minY:u,maxY:u+a}},nextByteOffset:e+4+3*o}}function O(t,e,n,s,a){const i=new Array(n);for(let r=0;r<n;r++){const{data:n,nextByteOffset:o}=t(s,a,e);i[r]=n,a=o}return{data:i,nextByteOffset:a}}let N=null;const L=new class{constructor(t,e){this.lastRealUpdate=performance.now(),this.nextValue=null,this.timeout=void 0,this.minDelay=t,this.updateConsumer=e}setValue(t){if(void 0!==this.timeout)return void(this.nextValue=t);const e=performance.now(),n=e-this.lastRealUpdate;if(n>=this.minDelay)return this.lastRealUpdate=e,void this.updateConsumer(t);const s=this.minDelay-n;this.timeout=setTimeout((()=>{this.timeout=void 0,null!==this.nextValue&&(this.updateConsumer(this.nextValue),this.nextValue=null)}),s)}abort(){void 0!==this.timeout&&(clearTimeout(this.timeout),this.timeout=void 0)}}(1e3/30,(t=>{if(N&&N.isOpen()){const e=new ArrayBuffer(9),n=new DataView(e),s=x.fromTransferable(t.viewBox);n.setFloat32(0,s.width/s.height,!1),n.setFloat32(4,t.targetAlpha,!1),n.setUint8(8,t.wantsToBeFast?1:0),N.sendBinary(e)}})),P=new class{constructor(){this.updateQueue=[],this.snakeDeaths=[],this.snakeNames=new Map}init(t){this.config=t.gameConfig,this.snakeNames.set(t.snakeId,t.snakeName)}nextUpdate(){const t=this.updateQueue.shift(),e=this.updateQueue.length>0,n=this.leaderboard;this.leaderboard=void 0;const s=this.snakeDeaths;return this.snakeDeaths=[],t&&t.snakeInfos.forEach((t=>t.name=this.snakeNames.get(t.id))),{ticksSinceLastUpdate:t?t.ticksSinceLastUpdate:0,snakes:t?t.snakeInfos:[],snakeChunks:t?t.snakeChunkData:[],foodChunks:t?t.foodChunkData:[],snakeDeaths:s,leaderboard:n,heatMap:t?.heatMap,moreUpdates:e}}addBinaryUpdate(t){const e=function(t,e){const n=new DataView(e),s=n.getUint8(0),a=n.getUint8(1),i=n.getUint8(2),r=n.getUint8(3),o=0!==n.getUint8(4),{data:c,nextByteOffset:h}=O(k,t,a,e,5),{data:u,nextByteOffset:l}=O(S,t,i,e,h),{data:d,nextByteOffset:m}=O(U,t,r,e,l);let f,p=m;if(o){const n=t.chunks.rows*t.chunks.columns;p+=n;const s=new Uint8Array(e,m,n);f=new Uint8Array(s)}return p!==e.byteLength&&console.error(`Unexpected update buffer size (expected ${p}, was ${e.byteLength})`),{ticksSinceLastUpdate:s,snakeInfos:c,snakeChunkData:u,foodChunkData:d,heatMap:f}}(this.config,t);this.updateQueue.push(e)}addJSONUpdate(t){switch(t.tag){case"SnakeDeathInfo":console.info(`Snake ${t.snakeId} has died.`),this.snakeDeaths.push(t.snakeId),this.snakeNames.delete(t.snakeId);break;case"Leaderboard":this.leaderboard={list:t.list},t.list.forEach((({id:t,name:e})=>this.snakeNames.set(t,e)));break;case"SnakeNameUpdate":for(const[e,n]of Object.entries(t.names)){const t=parseInt(e,10);this.snakeNames.set(t,n)}break;default:throw new Error(`Unexpected message from server. (tag = ${t.tag})`)}}},C=new Map;function I(t){const e=C.get(t);e&&e()}self.onerror=(t,e,n,s,a)=>{I("error")},r(new class{async init(t){if(null!==N)throw new Error("Worker is already initialized.");const e=`${t.server.wss?"wss":"ws"}://${t.server.host}:${t.server.port}/game`;N=await async function(t){const e=new WebSocket(t);return e.binaryType="arraybuffer",await new Promise(((t,n)=>{e.onopen=()=>{e.onopen=null,t()},e.onerror=()=>{e.onerror=null,n()}})),new w(e)}(e);const n=await new Promise(((t,e)=>{const n=setTimeout((()=>e(new Error("SpawnInfo timeout."))),2e3);N.onJSONMessage=e=>{"SpawnInfo"===e.tag?(clearTimeout(n),t(e)):console.warn("Game init: Unexpected message from server.",e)}}));return P.init(n),N.onJSONMessage=t=>{t.tag,P.addJSONUpdate(t),I("server-update")},N.onBinaryMessage=t=>{P.addBinaryUpdate(t),I("server-update")},N.onclose=()=>{I("disconnect"),self.close()},{config:P.config,targetSnakeId:n.snakeId,startPosition:n.snakePosition}}sendUserInput(t,e,n){L.setValue({targetAlpha:t,wantsToBeFast:e,viewBox:n})}getDataChanges(){const t=P.nextUpdate(),e=t.snakeChunks.map((t=>t.data.buffer));return t.heatMap&&e.push(t.heatMap.buffer),d(t,e)}quit(){N&&N.close(),self.close()}addEventListener(t,e){C.set(t,e)}})})();